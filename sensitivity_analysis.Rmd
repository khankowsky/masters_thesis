---
title: "sensitivity_analysis"
output: html_document
date: "2023-03-06"
---

```{r setup, include=FALSE}
library(tidyverse)
library(readxl)
library(janitor)
library(skimr)
library(data.table)
library(fuzzyjoin)
library(lubridate)
library(kableExtra)
library(modEvA)
library(GGally)
library(readr)

library(maps) # land masses
library(rgdal) # read OGR vector maps into Spatial objects
library(viridis) # for customizing scale bars
library(mapproj)
library(hexbin)
library(sf)
library(scales)
library(gridExtra)
library(openxlsx)
library(beepr)
library(purrr)
library(rsq)
library(asht)
library(car)
library(effects)
library(ggpubr)

```


# Functions 
```{r}

#creating a function to filter for the species of interest and create the explanatory variables 
rel_eff_func <- function(x) {
  x <- x %>%
  filter(SVSPP == 73 & SPECIES_ITIS == 164712 | #cod 
         SVSPP == 74 & SPECIES_ITIS == 164744 | #haddock
         SVSPP == 105 & SPECIES_ITIS == 172909 | #yellowtail flounder
         SVSPP == 102 & SPECIES_ITIS == 172877 | #american plaice
         SVSPP == 107 & SPECIES_ITIS == 172873 | #witch flounder
         SVSPP == 106 & SPECIES_ITIS == 172905 | #winter flounder
         SVSPP == 197 & SPECIES_ITIS == 164499   #goosefish
        ) %>%
  drop_na(sf_species_cpua, nefsc_species_cpua_LB) %>%
  filter(CATCHWT_updated > 0) %>%
  filter(sf_species_cpua > 0) %>%
  mutate(old_relative_efficiency = log(sf_species_cpua)/log(nefsc_species_cpua_LB)) %>%
  mutate(relative_efficiency = sf_species_cpua/(nefsc_species_cpua_LB + sf_species_cpua)) %>%
  mutate(mgmt_area = case_when(
    AREA_CODE %in% c(511, 512, 513, 514, 515) ~ "GOM", 
    AREA_CODE %in% c(521, 522, 526, 525, 561, 562, 551, 552) ~ "GB", 
    AREA_CODE %in% c(611, 612, 613, 539, 538, 537) ~ "SNE"
  )) %>%
  mutate(season = case_when(
    month(START_TOW_DATE_GMT.x) %in% c(03, 04, 05) ~ "Spring", 
    month(START_TOW_DATE_GMT.x) %in% c(09, 10, 11) ~ "Fall", 
  )) %>%
  mutate(dayNight = case_when(
    dayNight_sf == "day" & dayNight_nefsc == "day" ~ "day", 
    dayNight_sf == "night" & dayNight_nefsc == "night" ~ "night", 
    dayNight_sf == "day" & dayNight_nefsc == "night" ~ "mismatch",
    dayNight_sf == "night" & dayNight_nefsc == "day" ~ "mismatch", 
  )) %>%
  mutate(towTime = case_when(
    time_dif > 0 ~ "nefsc_first", 
    time_dif < 0 ~ "sf_first"
  )) %>%
  drop_na(AVGDEPTH, BOTTEMP, dayNight, towTime, mgmt_area) %>%
  distinct() 
}



#trying to  create functions because I will be running the same models for every species dataset 
covars <- c("season", "mgmt_area", "AVGDEPTH", "BOTTEMP", "dayNight", "towTime")
combos <- purrr::map(1:6, ~as.data.frame(t(combn(covars, .x))))

formulae <- combos %>%
  map_dfr(unite, col="formula", sep = " + ") %>%
  mutate(formula = paste0("relative_efficiency ~  VESSEL_NAME +", formula))



#fit models (takes dataset)
fit.models <- function(x, y) {
  y$formula_clean %>% purrr::map( ~glm(.x, family = binomial, data=x))
}


#compare models (takes list of models created by fit.models())
compare.models <- function(x) {
  clean_list_of_models[1:63][1] %>%
  mutate(aic =  purrr::map_dbl(x, AIC)) %>%
  mutate(rsq =  purrr::map_dbl(x, Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(x)]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE)
}


#creating a function to extract the optimal model 
extract_optimal_model <- function(x) {
  formulae %>%
  mutate(aic =  purrr::map_dbl(x, AIC)) %>%
  mutate(rsq =  purrr::map_dbl(x, Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[count(x)]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))
}


##############################################################################
#creating a function to filter for the species of interest and create the explanatory variables 
rel_eff_func_ob <- function(x) {
  x <- x %>%
  filter(SVSPP == 73 & NESPP4 == 818 | #cod 
         SVSPP == 74 & NESPP4 == 1477 | #haddock
         SVSPP == 105 & NESPP4 == 1230 | #yellowtail flounder
         SVSPP == 102 & NESPP4 == 1240 | #american plaice
         SVSPP == 107 & NESPP4 == 1220 | #witch flounder
         SVSPP == 106 & NESPP4 == 1200 | #winter flounder
         SVSPP == 197 & NESPP4 == 124    #monkfish
        ) %>%
  drop_na(ob_species_cpua, nefsc_species_cpua_LB) %>%
  filter(CATCHWT_updated > 0) %>%
  mutate(old_relative_efficiency = log(ob_species_cpua)/log(nefsc_species_cpua_LB)) %>%
  mutate(relative_efficiency = ob_species_cpua/(nefsc_species_cpua_LB + ob_species_cpua)) %>%
  mutate(mgmt_area = case_when(
    AREA.x %in% c(511, 512, 513, 514, 515) ~ "GOM", 
    AREA.x %in% c(521, 522, 526, 525, 561, 562, 551, 552) ~ "GB", 
    AREA.x %in% c(611, 612, 613, 539, 538, 537) ~ "SNE"
  )) %>%
  mutate(season = case_when(
    month(START_TOW_DATE_GMT) %in% c(02, 03, 04, 05) ~ "Spring", 
    month(START_TOW_DATE_GMT) %in% c(09, 10, 11) ~ "Fall", 
  )) %>%
  mutate(DayNight = case_when(
    dayNight_ob == "night" & dayNight_nefsc == "night" ~ "Night",
    dayNight_ob == "day" & dayNight_nefsc == "day" ~ "Day",
    dayNight_ob == "night" & dayNight_nefsc =="day" ~ "Mismatch",
    dayNight_ob == "day" & dayNight_nefsc == "night" ~ "Mismatch"
  )) %>%
  mutate(towTime = case_when(
    time_dif > 0 ~ "nefsc_first", 
    time_dif < 0 ~ "sf_first"
  )) %>%
  mutate(trawl_type = as.factor(trawl_type)) %>%
  drop_na(trawl_type) %>%
  drop_na(AVGDEPTH, BOTTEMP, DayNight, towTime) %>%
  distinct()
}


#creating a function for fitting the observer dataset models 
#trying to  create functions because I will be running the same models for every species dataset 
covars_ob <- c("season", "mgmt_area", "AVGDEPTH", "BOTTEMP", "DayNight", "towTime")
combos_ob <- purrr::map(1:6, ~as.data.frame(t(combn(covars_ob, .x))))

formulae_ob <- combos_ob %>%
  map_dfr(unite, col="formula_ob", sep = " + ") %>%
  mutate(formula_ob = paste0("relative_efficiency ~  trawl_type + ", formula_ob))


#fit models (takes dataset)
fit.models_ob <- function(x, y) {
  y$formula_clean %>% purrr::map( ~glm(.x, family = binomial, data=x))
}


###############################################################################
paired_tow_levels <- c("paired_tows_1mi_24hr", "paired_tows_1mi_48hr", 
                       "paired_tows_1mi_72hr", "paired_tows_1mi_96hr", 
                       "paired_tows_1mi_120hr", "paired_tows_1mi_144hr", 
                       "paired_tows_1mi_168hr", "paired_tows_1mi_192hr", 
    
                       "paired_tows_2mi_24hr", "paired_tows_2mi_48hr", 
                       "paired_tows_2mi_72hr", "paired_tows_2mi_96hr", 
                       "paired_tows_2mi_120hr", "paired_tows_2mi_144hr", 
                       "paired_tows_2mi_168hr", "paired_tows_2mi_192hr", 
                       
                       "paired_tows_3mi_24hr", "paired_tows_3mi_48hr", 
                       "paired_tows_3mi_72hr", "paired_tows_3mi_96hr", 
                       "paired_tows_3mi_120hr", "paired_tows_3mi_144hr", 
                       "paired_tows_3mi_168hr", "paired_tows_3mi_192hr", 
                       
                       "paired_tows_4mi_24hr", "paired_tows_4mi_48hr", 
                       "paired_tows_4mi_72hr", "paired_tows_4mi_96hr", 
                       "paired_tows_4mi_120hr", "paired_tows_4mi_144hr", 
                       "paired_tows_4mi_168hr", "paired_tows_4mi_192hr", 
                       
                       "paired_tows_5mi_24hr", "paired_tows_5mi_48hr", 
                       "paired_tows_5mi_72hr", "paired_tows_5mi_96hr", 
                       "paired_tows_5mi_120hr", "paired_tows_5mi_144hr", 
                       "paired_tows_5mi_168hr", "paired_tows_5mi_192hr",
                       
                       "paired_tows_6mi_24hr", "paired_tows_6mi_48hr", 
                       "paired_tows_6mi_72hr", "paired_tows_6mi_96hr", 
                       "paired_tows_6mi_120hr", "paired_tows_6mi_144hr", 
                       "paired_tows_6mi_168hr", "paired_tows_6mi_192hr",
                       
                       "paired_tows_7mi_24hr", "paired_tows_7mi_48hr", 
                       "paired_tows_7mi_72hr", "paired_tows_7mi_96hr", 
                       "paired_tows_7mi_120hr", "paired_tows_7mi_144hr", 
                       "paired_tows_7mi_168hr", "paired_tows_7mi_192hr",
                       
                       "paired_tows_8mi_24hr", "paired_tows_8mi_48hr", 
                       "paired_tows_8mi_72hr", "paired_tows_8mi_96hr", 
                       "paired_tows_8mi_120hr", "paired_tows_8mi_144hr", 
                       "paired_tows_8mi_168hr", "paired_tows_8mi_192hr"
                       )

paired_tow_levels_ob <- c("paired_tows_1mi_24hr", "paired_tows_1mi_48hr", 
                       "paired_tows_1mi_72hr", "paired_tows_1mi_96hr", 
                       "paired_tows_1mi_120hr", "paired_tows_1mi_144hr", 
                       "paired_tows_1mi_168hr", "paired_tows_1mi_192hr", 
    
                       "paired_tows_2mi_24hr", "paired_tows_2mi_48hr", 
                       "paired_tows_2mi_72hr", "paired_tows_2mi_96hr", 
                       "paired_tows_2mi_120hr", "paired_tows_2mi_144hr", 
                       "paired_tows_2mi_168hr", "paired_tows_2mi_192hr", 
                       
                       "paired_tows_3mi_24hr", "paired_tows_3mi_48hr", 
                       "paired_tows_3mi_72hr", "paired_tows_3mi_96hr", 
                       "paired_tows_3mi_120hr", "paired_tows_3mi_144hr", 
                       "paired_tows_3mi_168hr", "paired_tows_3mi_192hr", 
                       
                       "paired_tows_4mi_24hr", "paired_tows_4mi_48hr", 
                       "paired_tows_4mi_72hr", "paired_tows_4mi_96hr", 
                       "paired_tows_4mi_120hr", "paired_tows_4mi_144hr", 
                       "paired_tows_4mi_168hr", "paired_tows_4mi_192hr", 
                       
                       "paired_tows_5mi_24hr", "paired_tows_5mi_48hr", 
                       "paired_tows_5mi_72hr", "paired_tows_5mi_96hr", 
                       "paired_tows_5mi_120hr", "paired_tows_5mi_144hr", 
                       "paired_tows_5mi_168hr", "paired_tows_5mi_192hr"
                       )

```

```{r}
#fit models (takes dataset)
fit.models_old <- function(x) {
  formulae$formula %>% purrr::map( ~glm(.x, family = binomial, data=x))
}

#compare models (takes list of models created by fit.models())
compare.models_old <- function(x) {
  formulae %>%
  mutate(aic =  purrr::map_dbl(x, AIC)) %>%
  mutate(rsq =  purrr::map_dbl(x, Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(x)]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE)
}
```




# Running the relative efficiency analysis for all the datasets 
```{r}
#reading in the list of files, and then reading in all the datasets to a list 
filenames <- list.files(path = "data/sf_paired_data", recursive = TRUE, full.names = TRUE)
datasets <- lapply(filenames, read_csv)


#creating a dataset with all the sample size at each match 
datasets_tibble <- as_tibble_col(filenames, column_name = "dataset") %>%
  mutate(dataset = str_sub(dataset, 21, -5))


#running the relative efficiency calculation and filtering 
datasets_re <- lapply(datasets, rel_eff_func)


#adding the individual datasets to the overall dataset 
datasets_tibble <- datasets_tibble %>%
  mutate(data = datasets_re)

```

# Run Sensitivity Analysis for Each Species and for Both Study Fleet and Observer Matches 

# Study Fleet & NEFSC 
## Cod
```{r}
# only the stuff that actually works for cod 
#filtering the datasets for just cod
datasets_tibble_cod <- datasets_tibble %>%
  unnest(data) %>%
  filter(SVSPP == 73 & SPECIES_ITIS == 164712) %>%
  group_by(dataset) %>%
  distinct(EFFORT_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         sf_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_cod <- datasets_tibble_cod %>% 
  mutate(list_of_models = rep(list(formulae),64)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(dayNight), 
            towTime_n = n_distinct(towTime), 
            vessel_n = n_distinct(VESSEL_NAME), 
            n = n_distinct(EFFORT_ID)) %>%
  nest(data = 2:78) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula, "mgmt_area"), 
         season_dtc = str_detect(formula, "season"), 
         dayNight_dtc = str_detect(formula, "dayNight"), 
         towTime_dtc = str_detect(formula, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(vessel_n == 1, (str_replace(formula, "VESSEL_NAME +", "")), formula)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_cod <- datasets_tibble_cod$list_of_models


#fitting all the models to each dataset 
models_all_cod <- mapply(fit.models, datasets_tibble_cod$data, clean_list_of_models_cod)


#comparing all the models for all the datasets 
for (i in 1:64) {
comparison_tables <- clean_list_of_models_cod[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_cod[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_cod[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_cod[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables)

}


#extract the optimal model from each table 
for (i in 1:64) {
optimal_models <- clean_list_of_models_cod[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_cod[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_cod[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_cod[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_cod <- datasets_tibble_cod %>%
  mutate(optimal_model = c("relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight",
                           "relative_efficiency ~ dayNight", 
                           "relative_efficiency ~ dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + dayNight",
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + mgmt_area + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + mgmt_area + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + mgmt_area + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + mgmt_area + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + mgmt_area + AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + mgmt_area + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + mgmt_area + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + mgmt_area + AVGDEPTH + BOTTEMP + towTime",
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP"
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_cod <- datasets_tibble_cod %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_cod <- dataset_final_cod[match(paired_tow_levels, dataset_final_cod$dataset), ]


dataset_final_cod

#plotting the RE estimate and CV and sample size 
dataset_final_cod %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() 


#table for the important information 
dataset_final_cod %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()
  

```


## Haddock 
```{r}
# only the stuff that actually works for haddock 
#filtering the datasets for just haddock
datasets_tibble_haddock <- datasets_tibble %>%
  unnest(data) %>%
  filter(SVSPP == 74 & SPECIES_ITIS == 164744) %>%
  group_by(dataset) %>%
  distinct(EFFORT_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         sf_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_haddock <- datasets_tibble_haddock %>% 
  mutate(list_of_models = rep(list(formulae),64)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(dayNight), 
            towTime_n = n_distinct(towTime), 
            vessel_n = n_distinct(VESSEL_NAME), 
            n = n_distinct(EFFORT_ID)) %>%
  nest(data = 2:78) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula, "mgmt_area"), 
         season_dtc = str_detect(formula, "season"), 
         dayNight_dtc = str_detect(formula, "dayNight"), 
         towTime_dtc = str_detect(formula, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(vessel_n == 1, (str_replace(formula, "VESSEL_NAME +", "")), formula)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_haddock <- datasets_tibble_haddock$list_of_models


#fitting all the models to each dataset 
models_all_haddock <- mapply(fit.models, datasets_tibble_haddock$data, clean_list_of_models_haddock)


#comparing all the models for all the datasets 
for (i in 1:64) {
comparison_tables_haddock <- clean_list_of_models_haddock[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_haddock[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_haddock[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_haddock[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_haddock)

}


#extract the optimal model from each table 
for (i in 1:64) {
optimal_models_haddock <- clean_list_of_models_haddock[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_haddock[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_haddock[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_haddock[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_haddock)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_haddock <- datasets_tibble_haddock %>%
  mutate(optimal_model = c("relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area",
                           "relative_efficiency ~ AVGDEPTH",                                                           #5
                           "relative_efficiency ~ AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area",                                       #10
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season",                                                #15
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +towTime",
                           "relative_efficiency ~ VESSEL_NAME +towTime", 
                           "relative_efficiency ~ VESSEL_NAME +towTime",            #20
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP",                      #25
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + towTime",                         #30
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime",               #35
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP",                           #40
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area",                                              #45
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + towTime",    #50
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime",                          #55
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime",                #60
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime"
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_haddock <- datasets_tibble_haddock %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_haddock <- dataset_final_haddock[match(paired_tow_levels, dataset_final_haddock$dataset), ]


dataset_final_haddock

#plotting the RE estimate and CV and sample size 
dataset_final_haddock %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ", 
       title = "Haddock") + 
  coord_flip() 
  
  


#table for the important information 
dataset_final_haddock %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

```




## Witch Flounder 
```{r}
# only the stuff that actually works for witch flounder  
#filtering the datasets for just witch flounder 
datasets_tibble_witchfl <- datasets_tibble %>%
  unnest(data) %>%
  filter(SVSPP == 107 & SPECIES_ITIS == 172873) %>%
  group_by(dataset) %>%
  distinct(EFFORT_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         sf_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_witchfl <- datasets_tibble_witchfl %>% 
  mutate(list_of_models = rep(list(formulae),59)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(dayNight), 
            towTime_n = n_distinct(towTime), 
            vessel_n = n_distinct(VESSEL_NAME), 
            n = n_distinct(EFFORT_ID)) %>%
  nest(data = 2:78) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula, "mgmt_area"), 
         season_dtc = str_detect(formula, "season"), 
         dayNight_dtc = str_detect(formula, "dayNight"), 
         towTime_dtc = str_detect(formula, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(vessel_n == 1, (str_replace(formula, "VESSEL_NAME +", "")), formula)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_witchfl <- datasets_tibble_witchfl$list_of_models


#fitting all the models to each dataset 
models_all_witchfl <- mapply(fit.models, datasets_tibble_witchfl$data, clean_list_of_models_witchfl)


#comparing all the models for all the datasets 
for (i in 1:59) {
comparison_tables_witchfl <- clean_list_of_models_witchfl[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_witchfl[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_witchfl[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_witchfl[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_witchfl)

}


#extract the optimal model from each table 
for (i in 1:59) {
optimal_models_witchfl <- clean_list_of_models_witchfl[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_witchfl[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_witchfl[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_witchfl[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_witchfl)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_witchfl <- datasets_tibble_witchfl %>%
  mutate(optimal_model = c("relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season",
                           "relative_efficiency ~ AVGDEPTH",                                                           #5
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +towTime", 
                           "relative_efficiency ~ VESSEL_NAME +towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ AVGDEPTH",                                       #10
                           "relative_efficiency ~ AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + dayNight",                                                #15
                           "relative_efficiency ~ BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season",
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + dayNight + towTime",            #20
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +towTime",                      #25
                           "relative_efficiency ~ VESSEL_NAME +season + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight",                         #30
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +towTime", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + mgmt_area + AVGDEPTH + BOTTEMP + towTime",               #35
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH",                           #40
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +season + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight",                                              #45
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +towTime",    #50
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + dayNight",                          #55
                           "relative_efficiency ~ VESSEL_NAME +towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + towTime"
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_witchfl <- datasets_tibble_witchfl %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_witchfl <- dataset_final_witchfl[match(paired_tow_levels, dataset_final_witchfl$dataset), ]


dataset_final_witchfl

#plotting the RE estimate and CV and sample size 
dataset_final_witchfl %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  drop_na(dataset) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() + 
  theme(text = element_text(size = 15))


#table for the important information 
dataset_final_witchfl %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  drop_na(dataset) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

```


## Yellowtail Flounder 
```{r}
# only the stuff that actually works for yellowtail flounder  
#filtering the datasets for just yellowtail flounder 
datasets_tibble_yellowtailfl <- datasets_tibble %>%
  unnest(data) %>%
  filter(SVSPP == 105 & SPECIES_ITIS == 172909) %>%
  group_by(dataset) %>%
  distinct(EFFORT_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         sf_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_yellowtailfl <- datasets_tibble_yellowtailfl %>% 
  mutate(list_of_models = rep(list(formulae),64)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(dayNight), 
            towTime_n = n_distinct(towTime), 
            vessel_n = n_distinct(VESSEL_NAME), 
            n = n_distinct(EFFORT_ID)) %>%
  nest(data = 2:78) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula, "mgmt_area"), 
         season_dtc = str_detect(formula, "season"), 
         dayNight_dtc = str_detect(formula, "dayNight"), 
         towTime_dtc = str_detect(formula, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(vessel_n == 1, (str_replace(formula, "VESSEL_NAME +", "")), formula)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_yellowtailfl <- datasets_tibble_yellowtailfl$list_of_models


#fitting all the models to each dataset 
models_all_yellowtailfl <- mapply(fit.models, datasets_tibble_yellowtailfl$data, clean_list_of_models_yellowtailfl)


#comparing all the models for all the datasets 
for (i in 1:64) {
comparison_tables_yellowtailfl <- clean_list_of_models_yellowtailfl[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_yellowtailfl[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_yellowtailfl[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_yellowtailfl[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_yellowtailfl)

}


#extract the optimal model from each table 
for (i in 1:64) {
optimal_models_yellowtailfl <- clean_list_of_models_yellowtailfl[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_yellowtailfl[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_yellowtailfl[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_yellowtailfl[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_yellowtailfl)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_yellowtailfl <- datasets_tibble_yellowtailfl %>%
  mutate(optimal_model = c("relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season",
                           "relative_efficiency ~ AVGDEPTH",                                                           #5
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP",                                       #10
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP",                                                #15
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP",
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP",            #20
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP",                      #25
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP",                         #30
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP",               #35
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP",                           #40
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP",                                              #45
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight",    #50
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight",                          #55
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight",                #60
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight"
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_yellowtailfl <- datasets_tibble_yellowtailfl %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_yellowtailfl <- dataset_final_yellowtailfl[match(paired_tow_levels, dataset_final_yellowtailfl$dataset), ]


dataset_final_yellowtailfl

#plotting the RE estimate and CV and sample size 
dataset_final_yellowtailfl %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() 


#table for the important information 
dataset_final_yellowtailfl %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

```


## American Plaice 
```{r}
# only the stuff that actually works for american plaice 
#filtering the datasets for just american plaice
datasets_tibble_plaice <- datasets_tibble %>%
  unnest(data) %>%
  filter(SVSPP == 102 & SPECIES_ITIS == 172877) %>%
  group_by(dataset) %>%
  distinct(EFFORT_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         sf_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_plaice <- datasets_tibble_plaice %>% 
  mutate(list_of_models = rep(list(formulae),61)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(dayNight), 
            towTime_n = n_distinct(towTime), 
            vessel_n = n_distinct(VESSEL_NAME), 
            n = n_distinct(EFFORT_ID)) %>%
  nest(data = 2:78) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula, "mgmt_area"), 
         season_dtc = str_detect(formula, "season"), 
         dayNight_dtc = str_detect(formula, "dayNight"), 
         towTime_dtc = str_detect(formula, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(vessel_n == 1, (str_replace(formula, "VESSEL_NAME +", "")), formula)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_plaice <- datasets_tibble_plaice$list_of_models


#fitting all the models to each dataset 
models_all_plaice <- mapply(fit.models, datasets_tibble_plaice$data, clean_list_of_models_plaice)


#comparing all the models for all the datasets 
for (i in 1:61) {
comparison_tables_plaice <- clean_list_of_models_plaice[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_plaice[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_plaice[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_plaice[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_plaice)

}


#extract the optimal model from each table 
for (i in 1:61) {
optimal_models_plaice <- clean_list_of_models_plaice[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_plaice[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_plaice[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_plaice[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_plaice)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_plaice <- datasets_tibble_plaice %>%
  mutate(optimal_model = c("relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season",
                           "relative_efficiency ~ AVGDEPTH",                                                           #5
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + dayNight", 
                           "relative_efficiency ~ AVGDEPTH",                                       #10
                           "relative_efficiency ~ AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP",                                                #15
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season",
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP",            #20
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area",                      #25
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP",                         #30
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + towTime",               #35
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + towTime",                           #40
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight + towTime",                                              #45
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + dayNight",    #50
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime",                          #55
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH",                #60
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH" #61
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_plaice <- datasets_tibble_plaice %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_plaice <- dataset_final_plaice[match(paired_tow_levels, dataset_final_plaice$dataset), ]


dataset_final_plaice 

#plotting the RE estimate and CV and sample size 
dataset_final_plaice %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  drop_na(dataset) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() + 
  theme(text = element_text(size = 15))


#table for the important information 
dataset_final_plaice %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  drop_na(dataset) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()
```


## Winter Flounder 
```{r}
# only the stuff that actually works for winter flounder 
#filtering the datasets for just winter flounder
datasets_tibble_winterfl <- datasets_tibble %>%
  unnest(data) %>%
  filter(SVSPP == 106 & SPECIES_ITIS == 172905) %>%
  group_by(dataset) %>%
  distinct(EFFORT_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         sf_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_winterfl <- datasets_tibble_winterfl %>% 
  mutate(list_of_models = rep(list(formulae),64)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(dayNight), 
            towTime_n = n_distinct(towTime), 
            vessel_n = n_distinct(VESSEL_NAME), 
            n = n_distinct(EFFORT_ID)) %>%
  nest(data = 2:78) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula, "mgmt_area"), 
         season_dtc = str_detect(formula, "season"), 
         dayNight_dtc = str_detect(formula, "dayNight"), 
         towTime_dtc = str_detect(formula, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(vessel_n == 1, (str_replace(formula, "VESSEL_NAME +", "")), formula)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_winterfl <- datasets_tibble_winterfl$list_of_models


#fitting all the models to each dataset 
models_all_winterfl <- mapply(fit.models, datasets_tibble_winterfl$data, clean_list_of_models_winterfl)


#comparing all the models for all the datasets 
for (i in 1:64) {
comparison_tables_winterfl <- clean_list_of_models_winterfl[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_winterfl[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_winterfl[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_winterfl[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_winterfl)

}


#extract the optimal model from each table 
for (i in 1:64) {
optimal_models_winterfl <- clean_list_of_models_winterfl[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_winterfl[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_winterfl[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_winterfl[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_winterfl)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_winterfl <- datasets_tibble_winterfl %>%
  mutate(optimal_model = c("relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH",
                           "relative_efficiency ~ AVGDEPTH",                                                           #5
                           "relative_efficiency ~ AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH",                                       #10
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP",                                                #15
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season",
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season",            #20
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH",                      #25
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP",                         #30
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime",               #35
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP",                           #40
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP",                                              #45
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP",    #50
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight",                          #55
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + AVGDEPTH + BOTTEMP",                #60
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +dayNight"
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_winterfl <- datasets_tibble_winterfl %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_winterfl <- dataset_final_winterfl[match(paired_tow_levels, dataset_final_winterfl$dataset), ]


dataset_final_winterfl

#plotting the RE estimate and CV and sample size 
dataset_final_winterfl %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() + 
  theme(text = element_text(size = 15))

#table for the important information 
dataset_final_winterfl %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

```


## Monkfish 
```{r}
# only the stuff that actually works for monkfish 
#filtering the datasets for just monkfish
datasets_tibble_monkfish <- datasets_tibble %>%
  unnest(data) %>%
  filter(SVSPP == 197 & SPECIES_ITIS == 164499) %>%
  group_by(dataset) %>%
  distinct(EFFORT_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         sf_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_monkfish <- datasets_tibble_monkfish %>% 
  mutate(list_of_models = rep(list(formulae),64)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(dayNight), 
            towTime_n = n_distinct(towTime), 
            vessel_n = n_distinct(VESSEL_NAME), 
            n = n_distinct(EFFORT_ID)) %>%
  nest(data = 2:78) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula, "mgmt_area"), 
         season_dtc = str_detect(formula, "season"), 
         dayNight_dtc = str_detect(formula, "dayNight"), 
         towTime_dtc = str_detect(formula, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(vessel_n == 1, (str_replace(formula, "VESSEL_NAME +", "")), formula)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_monkfish <- datasets_tibble_monkfish$list_of_models


#fitting all the models to each dataset 
# models_all_monkfish <- mapply(fit.models, datasets_tibble_monkfish$data, clean_list_of_models_monkfish)
models_all_monkfish <- lapply(datasets_tibble_monkfish$data, fit.models_old)


#comparing all the models for all the datasets 
for (i in 1:64) {
comparison_tables_monkfish <- clean_list_of_models_monkfish[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_monkfish[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_monkfish[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_monkfish[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_monkfish)

}


#extract the optimal model from each table 
for (i in 1:64) {
optimal_models_monkfish <- clean_list_of_models_monkfish[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_monkfish[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_monkfish[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_monkfish[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_monkfish)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_monkfish <- datasets_tibble_monkfish %>%
  mutate(optimal_model = c("relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +towTime", 
                           "relative_efficiency ~ VESSEL_NAME +towTime",
                           "relative_efficiency ~ VESSEL_NAME +season",                                                           #5
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area",                                       #10
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area",                                                #15
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime",
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + dayNight + towTime",            #20
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + towTime",                      #25
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +towTime",                         #30
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + AVGDEPTH + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + dayNight + towTime",               #35
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +season", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight + towTime",                           #40
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP",                                              #45
                           "relative_efficiency ~ VESSEL_NAME +season + mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +season + mgmt_area", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + dayNight + towTime",    #50
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +season + BOTTEMP", 
                           "relative_efficiency ~ VESSEL_NAME +dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight + towTime",                          #55
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime",                #60
                           "relative_efficiency ~ VESSEL_NAME +mgmt_area + towTime", 
                           "relative_efficiency ~ VESSEL_NAME +towTime", 
                           "relative_efficiency ~ VESSEL_NAME +BOTTEMP + dayNight", 
                           "relative_efficiency ~ VESSEL_NAME +AVGDEPTH + BOTTEMP + towTime"
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_monkfish <- datasets_tibble_monkfish %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_monkfish <- dataset_final_monkfish[match(paired_tow_levels, dataset_final_monkfish$dataset), ]


dataset_final_monkfish

#plotting the RE estimate and CV and sample size 
dataset_final_monkfish %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() + 
  theme(text = element_text(size = 15))


#table for the important information 
dataset_final_monkfish %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()
```




###############################################################################
########################                            ###########################
###############################################################################

# Observer & NEFSC 
## Running Sensitivity Analysis for Observer Data
```{r}
#reading in the list of files, and then reading in all the datasets to a list 
filenames_ob <- list.files(path = "data/ob_paired_data", recursive = TRUE, full.names = TRUE)
datasets_ob <- lapply(filenames_ob, read_csv)


#creating a dataset with all the sample size at each match 
datasets_tibble_ob <- as_tibble_col(filenames_ob, column_name = "dataset") %>%
  mutate(dataset = str_sub(dataset, 21, -5))


#running the relative efficiency calculation and filtering 
datasets_re_ob <- lapply(datasets_ob, rel_eff_func_ob)


#adding the individual datasets to the overall dataset 
datasets_tibble_ob <- datasets_tibble_ob %>%
  mutate(data = datasets_re_ob)

```


## Cod
```{r}
#filtering the datasets for just cod
datasets_tibble_cod_ob <- datasets_tibble_ob %>%
  unnest(data) %>%
  filter(SVSPP == 73 & NESPP4 == 818) %>%
  group_by(dataset) %>%
  distinct(trip_haul_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         ob_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_cod_ob <- datasets_tibble_cod_ob %>% 
  mutate(list_of_models = rep(list(formulae_ob),40)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(DayNight), 
            towTime_n = n_distinct(towTime), 
            trawl_n = n_distinct(trawl_type), 
            n = n_distinct(trip_haul_ID)) %>%
  nest(data = 2:91) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula_ob, "mgmt_area"), 
         season_dtc = str_detect(formula_ob, "season"), 
         dayNight_dtc = str_detect(formula_ob, "DayNight"), 
         towTime_dtc = str_detect(formula_ob, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(trawl_n == 1, (str_replace(formula_ob, "trawl_type +", "")), formula_ob)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_cod_ob <- datasets_tibble_cod_ob$list_of_models


#fitting all the models to each dataset 
models_all_cod_ob <- mapply(fit.models_ob, datasets_tibble_cod_ob$data, clean_list_of_models_cod_ob)


#comparing all the models for all the datasets 
for (i in 1:40) {
comparison_tables_cod_ob <- clean_list_of_models_cod_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_cod_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_cod_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_cod_ob[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_cod_ob)

}


#extract the optimal model from each table 
for (i in 1:40) {
optimal_models_cod_ob <- clean_list_of_models_cod_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_cod_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_cod_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_cod_ob[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_cod_ob)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_cod_ob <- datasets_tibble_cod_ob %>%
  mutate(optimal_model = c("relative_efficiency ~ trawl_type + AVGDEPTH", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH",
                           "relative_efficiency ~ trawl_type + AVGDEPTH", #5
                           "relative_efficiency ~ trawl_type + AVGDEPTH", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + towTime", 
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH", #10
                           "relative_efficiency ~ trawl_type + season + mgmt_area + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + towTime", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH", 
                           "relative_efficiency ~ trawl_type + towTime", 
                           "relative_efficiency ~ trawl_type + towTime", #15
                           "relative_efficiency ~ trawl_type + BOTTEMP + DayNight", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + towTime",
                           "relative_efficiency ~ trawl_type + season + mgmt_area + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + towTime", #20
                           "relative_efficiency ~ trawl_type + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + mgmt_area + DayNight + towTime", 
                           "relative_efficiency ~ trawl_type + mgmt_area + DayNight + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + DayNight + towTime", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH + BOTTEMP + DayNight", #25
                           "relative_efficiency ~ trawl_type + season + DayNight", 
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH + DayNight", 
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH + DayNight", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH + BOTTEMP + DayNight", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH + DayNight", #30
                           "relative_efficiency ~ trawl_type + AVGDEPTH + DayNight", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH + DayNight", 
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH + DayNight", 
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH + DayNight", 
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH + DayNight", #35
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH + DayNight + towTime", 
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH + BOTTEMP + DayNight", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH + BOTTEMP + DayNight", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH + BOTTEMP + DayNight"  #40
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_cod_ob <- datasets_tibble_cod_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  ungroup() %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_cod_ob <- dataset_final_cod_ob[match(paired_tow_levels_ob, dataset_final_cod$dataset), ]


dataset_final_cod_ob

#plotting the RE estimate and SE and sample size 
dataset_final_cod_ob %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() 


#plotting the RE estimate and SE and sample size by trawl type
datasets_tibble_cod_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted_vals = purrr::map(model, fitted)) %>% 
  mutate(data = map2(data, fitted_vals, ~mutate(.x, fitted = .y))) %>%
  unnest(data) %>%
  group_by(dataset, trawl_type) %>%
  summarise(mean_re_bytrawl = mean(fitted), 
         cv_bytrawl = (sd(fitted)/mean(fitted)), 
         se_bytrawl = sd(fitted)/(sqrt(length(fitted))), 
         n_bytrawl = n_distinct(trip_haul_ID)) %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", sum(n_bytrawl), ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re_bytrawl, color = trawl_type)) + 
  geom_errorbar(aes(x = label, ymin = mean_re_bytrawl - se_bytrawl, ymax = mean_re_bytrawl + se_bytrawl, color = trawl_type)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  scale_color_discrete(labels=c("1" = "Groundfish Trawls", "2" = "Flatfish Trawls",
                              "3" = "Separator Trawls", "4" = "Eliminator Trawls")) + 
  coord_flip() 


  

#table for the important information 
dataset_final_cod_ob %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

```




## Haddock 
```{r}
#filtering the datasets for just cod
datasets_tibble_haddock_ob <- datasets_tibble_ob %>%
  unnest(data) %>%
  filter(SVSPP == 74 & NESPP4 == 1477) %>%
  group_by(dataset) %>%
  distinct(trip_haul_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         ob_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_haddock_ob <- datasets_tibble_haddock_ob %>% 
  mutate(list_of_models = rep(list(formulae_ob),40)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(DayNight), 
            towTime_n = n_distinct(towTime), 
            trawl_n = n_distinct(trawl_type), 
            n = n_distinct(trip_haul_ID)) %>%
  nest(data = 2:91) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula_ob, "mgmt_area"), 
         season_dtc = str_detect(formula_ob, "season"), 
         dayNight_dtc = str_detect(formula_ob, "DayNight"), 
         towTime_dtc = str_detect(formula_ob, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(trawl_n == 1, (str_replace(formula_ob, "trawl_type +", "")), formula_ob)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_haddock_ob <- datasets_tibble_haddock_ob$list_of_models


#fitting all the models to each dataset 
models_all_haddock_ob <- mapply(fit.models_ob, datasets_tibble_haddock_ob$data, clean_list_of_models_haddock_ob)


#comparing all the models for all the datasets 
for (i in 1:40) {
comparison_tables_haddock_ob <- clean_list_of_models_haddock_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_haddock_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_haddock_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_haddock_ob[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_haddock_ob)

}


#extract the optimal model from each table 
for (i in 1:40) {
optimal_models_haddock_ob <- clean_list_of_models_haddock_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_haddock_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_haddock_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_haddock_ob[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_haddock_ob)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_haddock_ob <- datasets_tibble_haddock_ob %>%
  mutate(optimal_model = c("relative_efficiency ~ trawl_type + season + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + season + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + mgmt_area + AVGDEPTH + BOTTEMP", 
                           "relative_efficiency ~ trawl_type + mgmt_area + AVGDEPTH + BOTTEMP",
                           "relative_efficiency ~ BOTTEMP", #5
                           "relative_efficiency ~ trawl_type + mgmt_area", 
                           "relative_efficiency ~ trawl_type + mgmt_area", 
                           "relative_efficiency ~ trawl_type + mgmt_area", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + BOTTEMP + DayNight + towTime", #10
                           "relative_efficiency ~ trawl_type + season + mgmt_area + AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + towTime", 
                           "relative_efficiency ~ trawl_type + AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + mgmt_area + towTime", #15
                           "relative_efficiency ~ trawl_type + mgmt_area + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + AVGDEPTH + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + towTime",
                           "relative_efficiency ~ trawl_type + season + mgmt_area + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + AVGDEPTH + towTime", #20
                           "relative_efficiency ~ trawl_type + towTime", 
                           "relative_efficiency ~ trawl_type + mgmt_area + towTime", 
                           "relative_efficiency ~ trawl_type + mgmt_area + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + mgmt_area + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + AVGDEPTH + towTime", #25
                           "relative_efficiency ~ trawl_type + season + mgmt_area + AVGDEPTH + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + AVGDEPTH + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + AVGDEPTH + towTime", 
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + towTime", #30
                           "relative_efficiency ~ trawl_type + season + mgmt_area + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + AVGDEPTH + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + AVGDEPTH + BOTTEMP + DayNight + towTime", 
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH + towTime", #35
                           "relative_efficiency ~ trawl_type + season + AVGDEPTH + BOTTEMP + towTime", 
                           "relative_efficiency ~ trawl_type + season + BOTTEMP", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + DayNight + towTime", 
                           "relative_efficiency ~ trawl_type + mgmt_area + DayNight + towTime", 
                           "relative_efficiency ~ trawl_type + season + mgmt_area + BOTTEMP + DayNight + towTime"  #40
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_haddock_ob <- datasets_tibble_haddock_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  ungroup() %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_haddock_ob <- dataset_final_haddock_ob[match(paired_tow_levels_ob, dataset_final_haddock$dataset), ]


dataset_final_haddock_ob

#plotting the RE estimate and SE and sample size 
dataset_final_haddock_ob %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() 


#plotting the RE estimate and SE and sample size by trawl type
datasets_tibble_haddock_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted_vals = purrr::map(model, fitted)) %>% 
  mutate(data = map2(data, fitted_vals, ~mutate(.x, fitted = .y))) %>%
  unnest(data) %>%
  group_by(dataset, trawl_type) %>%
  summarise(mean_re_bytrawl = mean(fitted), 
         cv_bytrawl = (sd(fitted)/mean(fitted)), 
         se_bytrawl = sd(fitted)/(sqrt(length(fitted))), 
         n_bytrawl = n_distinct(trip_haul_ID)) %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", sum(n_bytrawl), ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re_bytrawl, color = trawl_type)) + 
  geom_errorbar(aes(x = label, ymin = mean_re_bytrawl - se_bytrawl, ymax = mean_re_bytrawl + se_bytrawl, color = trawl_type)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  scale_color_discrete(labels=c("1" = "Groundfish Trawls", "2" = "Flatfish Trawls",
                              "3" = "Separator Trawls", "4" = "Eliminator Trawls")) + 
  coord_flip() 


  

#table for the important information 
dataset_final_haddock %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()
```



## Witch Flounder 
```{r}
#filtering the datasets for just cod
datasets_tibble_witchfl_ob <- datasets_tibble_ob %>%
  unnest(data) %>%
  filter(SVSPP == 107 & NESPP4 == 1220) %>%
  group_by(dataset) %>%
  distinct(trip_haul_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         ob_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_witchfl_ob <- datasets_tibble_witchfl_ob %>% 
  mutate(list_of_models = rep(list(formulae_ob),40)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(DayNight), 
            towTime_n = n_distinct(towTime), 
            trawl_n = n_distinct(trawl_type), 
            n = n_distinct(trip_haul_ID)) %>%
  nest(data = 2:91) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula_ob, "mgmt_area"), 
         season_dtc = str_detect(formula_ob, "season"), 
         dayNight_dtc = str_detect(formula_ob, "DayNight"), 
         towTime_dtc = str_detect(formula_ob, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(trawl_n == 1, (str_replace(formula_ob, "trawl_type +", "")), formula_ob)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_witchfl_ob <- datasets_tibble_witchfl_ob$list_of_models


#fitting all the models to each dataset 
models_all_witchfl_ob <- mapply(fit.models_ob, datasets_tibble_witchfl_ob$data, clean_list_of_models_witchfl_ob)


#comparing all the models for all the datasets 
for (i in 1:40) {
comparison_tables_witchfl_ob <- clean_list_of_models_witchfl_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_witchfl_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_witchfl_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_witchfl_ob[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_witchfl_ob)

}


#extract the optimal model from each table 
for (i in 1:40) {
optimal_models_witchfl_ob <- clean_list_of_models_witchfl_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_witchfl_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_witchfl_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_witchfl_ob[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_witchfl_ob)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_witchfl_ob <- datasets_tibble_witchfl_ob %>%
  mutate(optimal_model = c("", 
                           "", 
                           "", 
                           "",
                           "", #5
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #10
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #15
                           "", 
                           "", 
                           "",
                           "", 
                           "", #20
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #25
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #30
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #35
                           "", 
                           "", 
                           "", 
                           "", 
                           ""  #40
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_witchfl_ob <- datasets_tibble_witchfl_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  ungroup() %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_witchfl_ob <- dataset_final_witchfl_ob[match(paired_tow_levels_ob, dataset_final_witchfl$dataset), ]


dataset_final_witchfl_ob

#plotting the RE estimate and SE and sample size 
dataset_final_witchfl_ob %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() 


#plotting the RE estimate and SE and sample size by trawl type
datasets_tibble_witchfl_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted_vals = purrr::map(model, fitted)) %>% 
  mutate(data = map2(data, fitted_vals, ~mutate(.x, fitted = .y))) %>%
  unnest(data) %>%
  group_by(dataset, trawl_type) %>%
  summarise(mean_re_bytrawl = mean(fitted), 
         cv_bytrawl = (sd(fitted)/mean(fitted)), 
         se_bytrawl = sd(fitted)/(sqrt(length(fitted))), 
         n_bytrawl = n_distinct(trip_haul_ID)) %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", sum(n_bytrawl), ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re_bytrawl, color = trawl_type)) + 
  geom_errorbar(aes(x = label, ymin = mean_re_bytrawl - se_bytrawl, ymax = mean_re_bytrawl + se_bytrawl, color = trawl_type)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  scale_color_discrete(labels=c("1" = "Groundfish Trawls", "2" = "Flatfish Trawls",
                              "3" = "Separator Trawls", "4" = "Eliminator Trawls")) + 
  coord_flip() 


  

#table for the important information 
dataset_final_witchfl_ob %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()
```



## Yellowtail Flounder 
```{r}
#filtering the datasets for just cod
datasets_tibble_yellowtailfl_ob <- datasets_tibble_ob %>%
  unnest(data) %>%
  filter(SVSPP == 105 & NESPP4 == 1230) %>%
  group_by(dataset) %>%
  distinct(trip_haul_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         ob_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_yellowtailfl_ob <- datasets_tibble_yellowtailfl_ob %>% 
  mutate(list_of_models = rep(list(formulae_ob),40)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(DayNight), 
            towTime_n = n_distinct(towTime), 
            trawl_n = n_distinct(trawl_type), 
            n = n_distinct(trip_haul_ID)) %>%
  nest(data = 2:91) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula_ob, "mgmt_area"), 
         season_dtc = str_detect(formula_ob, "season"), 
         dayNight_dtc = str_detect(formula_ob, "DayNight"), 
         towTime_dtc = str_detect(formula_ob, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(trawl_n == 1, (str_replace(formula_ob, "trawl_type +", "")), formula_ob)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_yellowtailfl_ob <- datasets_tibble_yellowtailfl_ob$list_of_models


#fitting all the models to each dataset 
models_all_yellowtailfl_ob <- mapply(fit.models_ob, datasets_tibble_yellowtailfl_ob$data, clean_list_of_models_yellowtailfl_ob)


#comparing all the models for all the datasets 
for (i in 1:40) {
comparison_tables_yellowtailfl_ob <- clean_list_of_models_yellowtailfl_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_yellowtailfl_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_yellowtailfl_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_yellowtailfl_ob[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_yellowtailfl_ob)

}


#extract the optimal model from each table 
for (i in 1:40) {
optimal_models_yellowtailfl_ob <- clean_list_of_models_yellowtailfl_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_yellowtailfl_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_yellowtailfl_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_yellowtailfl_ob[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_yellowtailfl_ob)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_yellowtailfl_ob <- datasets_tibble_yellowtailfl_ob %>%
  mutate(optimal_model = c("", 
                           "", 
                           "", 
                           "",
                           "", #5
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #10
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #15
                           "", 
                           "", 
                           "",
                           "", 
                           "", #20
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #25
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #30
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #35
                           "", 
                           "", 
                           "", 
                           "", 
                           ""  #40
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_yellowtailfl_ob <- datasets_tibble_yellowtailfl_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  ungroup() %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_yellowtailfl_ob <- dataset_final_yellowtailfl_ob[match(paired_tow_levels_ob, dataset_final_yellowtailfl$dataset), ]


dataset_final_yellowtailfl_ob

#plotting the RE estimate and SE and sample size 
dataset_final_yellowtailfl_ob %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() 


#plotting the RE estimate and SE and sample size by trawl type
datasets_tibble_yellowtailfl_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted_vals = purrr::map(model, fitted)) %>% 
  mutate(data = map2(data, fitted_vals, ~mutate(.x, fitted = .y))) %>%
  unnest(data) %>%
  group_by(dataset, trawl_type) %>%
  summarise(mean_re_bytrawl = mean(fitted), 
         cv_bytrawl = (sd(fitted)/mean(fitted)), 
         se_bytrawl = sd(fitted)/(sqrt(length(fitted))), 
         n_bytrawl = n_distinct(trip_haul_ID)) %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", sum(n_bytrawl), ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re_bytrawl, color = trawl_type)) + 
  geom_errorbar(aes(x = label, ymin = mean_re_bytrawl - se_bytrawl, ymax = mean_re_bytrawl + se_bytrawl, color = trawl_type)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  scale_color_discrete(labels=c("1" = "Groundfish Trawls", "2" = "Flatfish Trawls",
                              "3" = "Separator Trawls", "4" = "Eliminator Trawls")) + 
  coord_flip() 


  

#table for the important information 
dataset_final_yellowtailfl_ob %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()
```


## American Plaice 
```{r}
#filtering the datasets for just cod
datasets_tibble_plaice_ob <- datasets_tibble_ob %>%
  unnest(data) %>%
  filter(SVSPP == 102 & NESPP4 == 1240) %>%
  group_by(dataset) %>%
  distinct(trip_haul_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         ob_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_plaice_ob <- datasets_tibble_plaice_ob %>% 
  mutate(list_of_models = rep(list(formulae_ob),40)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(DayNight), 
            towTime_n = n_distinct(towTime), 
            trawl_n = n_distinct(trawl_type), 
            n = n_distinct(trip_haul_ID)) %>%
  nest(data = 2:91) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula_ob, "mgmt_area"), 
         season_dtc = str_detect(formula_ob, "season"), 
         dayNight_dtc = str_detect(formula_ob, "DayNight"), 
         towTime_dtc = str_detect(formula_ob, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(trawl_n == 1, (str_replace(formula_ob, "trawl_type +", "")), formula_ob)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_plaice_ob <- datasets_tibble_plaice_ob$list_of_models


#fitting all the models to each dataset 
models_all_plaice_ob <- mapply(fit.models_ob, datasets_tibble_plaice_ob$data, clean_list_of_models_plaice_ob)


#comparing all the models for all the datasets 
for (i in 1:40) {
comparison_tables_plaice_ob <- clean_list_of_models_plaice_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_plaice_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_plaice_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_plaice_ob[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_plaice_ob)

}


#extract the optimal model from each table 
for (i in 1:40) {
optimal_models_plaice_ob <- clean_list_of_models_plaice_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_plaice_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_plaice_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_plaice_ob[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_plaice_ob)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_plaice_ob <- datasets_tibble_plaice_ob %>%
  mutate(optimal_model = c("", 
                           "", 
                           "", 
                           "",
                           "", #5
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #10
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #15
                           "", 
                           "", 
                           "",
                           "", 
                           "", #20
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #25
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #30
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #35
                           "", 
                           "", 
                           "", 
                           "", 
                           ""  #40
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_plaice_ob <- datasets_tibble_plaice_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  ungroup() %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_plaice_ob <- dataset_final_plaice_ob[match(paired_tow_levels_ob, dataset_final_plaice$dataset), ]


dataset_final_plaice_ob

#plotting the RE estimate and SE and sample size 
dataset_final_plaice_ob %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() 


#plotting the RE estimate and SE and sample size by trawl type
datasets_tibble_plaice_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted_vals = purrr::map(model, fitted)) %>% 
  mutate(data = map2(data, fitted_vals, ~mutate(.x, fitted = .y))) %>%
  unnest(data) %>%
  group_by(dataset, trawl_type) %>%
  summarise(mean_re_bytrawl = mean(fitted), 
         cv_bytrawl = (sd(fitted)/mean(fitted)), 
         se_bytrawl = sd(fitted)/(sqrt(length(fitted))), 
         n_bytrawl = n_distinct(trip_haul_ID)) %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", sum(n_bytrawl), ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re_bytrawl, color = trawl_type)) + 
  geom_errorbar(aes(x = label, ymin = mean_re_bytrawl - se_bytrawl, ymax = mean_re_bytrawl + se_bytrawl, color = trawl_type)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  scale_color_discrete(labels=c("1" = "Groundfish Trawls", "2" = "Flatfish Trawls",
                              "3" = "Separator Trawls", "4" = "Eliminator Trawls")) + 
  coord_flip() 


  

#table for the important information 
dataset_final_plaice_ob %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()
```


## Winter Flounder 
```{r}
#filtering the datasets for just cod
datasets_tibble_winterfl_ob <- datasets_tibble_ob %>%
  unnest(data) %>%
  filter(SVSPP == 106 & NESPP4 == 1200) %>%
  group_by(dataset) %>%
  distinct(trip_haul_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         ob_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_winterfl_ob <- datasets_tibble_winterfl_ob %>% 
  mutate(list_of_models = rep(list(formulae_ob),40)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(DayNight), 
            towTime_n = n_distinct(towTime), 
            trawl_n = n_distinct(trawl_type), 
            n = n_distinct(trip_haul_ID)) %>%
  nest(data = 2:91) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula_ob, "mgmt_area"), 
         season_dtc = str_detect(formula_ob, "season"), 
         dayNight_dtc = str_detect(formula_ob, "DayNight"), 
         towTime_dtc = str_detect(formula_ob, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(trawl_n == 1, (str_replace(formula_ob, "trawl_type +", "")), formula_ob)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_winterfl_ob <- datasets_tibble_winterfl_ob$list_of_models


#fitting all the models to each dataset 
models_all_winterfl_ob <- mapply(fit.models_ob, datasets_tibble_winterfl_ob$data, clean_list_of_models_winterfl_ob)


#comparing all the models for all the datasets 
for (i in 1:40) {
comparison_tables_winterfl_ob <- clean_list_of_models_winterfl_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_winterfl_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_winterfl_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_winterfl_ob[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_winterfl_ob)

}


#extract the optimal model from each table 
for (i in 1:40) {
optimal_models_winterfl_ob <- clean_list_of_models_winterfl_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_winterfl_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_winterfl_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_winterfl_ob[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_winterfl_ob)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_winterfl_ob <- datasets_tibble_winterfl_ob %>%
  mutate(optimal_model = c("", 
                           "", 
                           "", 
                           "",
                           "", #5
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #10
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #15
                           "", 
                           "", 
                           "",
                           "", 
                           "", #20
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #25
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #30
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #35
                           "", 
                           "", 
                           "", 
                           "", 
                           ""  #40
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_winterfl_ob <- datasets_tibble_winterfl_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  ungroup() %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_winterfl_ob <- dataset_final_winterfl_ob[match(paired_tow_levels_ob, dataset_final_winterfl$dataset), ]


dataset_final_winterfl_ob

#plotting the RE estimate and SE and sample size 
dataset_final_winterfl_ob %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() 


#plotting the RE estimate and SE and sample size by trawl type
datasets_tibble_winterfl_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted_vals = purrr::map(model, fitted)) %>% 
  mutate(data = map2(data, fitted_vals, ~mutate(.x, fitted = .y))) %>%
  unnest(data) %>%
  group_by(dataset, trawl_type) %>%
  summarise(mean_re_bytrawl = mean(fitted), 
         cv_bytrawl = (sd(fitted)/mean(fitted)), 
         se_bytrawl = sd(fitted)/(sqrt(length(fitted))), 
         n_bytrawl = n_distinct(trip_haul_ID)) %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", sum(n_bytrawl), ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re_bytrawl, color = trawl_type)) + 
  geom_errorbar(aes(x = label, ymin = mean_re_bytrawl - se_bytrawl, ymax = mean_re_bytrawl + se_bytrawl, color = trawl_type)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  scale_color_discrete(labels=c("1" = "Groundfish Trawls", "2" = "Flatfish Trawls",
                              "3" = "Separator Trawls", "4" = "Eliminator Trawls")) + 
  coord_flip() 


  

#table for the important information 
dataset_final_winterfl_ob %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()
```


## Monkfish 
```{r}
#filtering the datasets for just cod
datasets_tibble_monkfish_ob <- datasets_tibble_ob %>%
  unnest(data) %>%
  filter(SVSPP == 197 & NESPP4 == 124) %>%
  group_by(dataset) %>%
  distinct(trip_haul_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(nefsc_species_cpua_LB < 10000, 
         ob_species_cpua < 10000) %>%
  group_by(dataset) %>%
  nest() %>%
  ungroup()


#creating a list of models, and removing models for which there are only one level of the categorical variables and then cleaning up the list of models 
datasets_tibble_monkfish_ob <- datasets_tibble_monkfish_ob %>% 
  mutate(list_of_models = rep(list(formulae_ob),40)) %>%
  unnest(data) %>%
  group_by(dataset) %>%
  mutate(mgmt_area_n = n_distinct(mgmt_area), 
            season_n = n_distinct(season), 
            dayNight_n = n_distinct(DayNight), 
            towTime_n = n_distinct(towTime), 
            trawl_n = n_distinct(trawl_type), 
            n = n_distinct(trip_haul_ID)) %>%
  nest(data = 2:91) %>%
  ungroup() %>%
  unnest(list_of_models) %>%  
  mutate(mgmt_area_dtc = str_detect(formula_ob, "mgmt_area"), 
         season_dtc = str_detect(formula_ob, "season"), 
         dayNight_dtc = str_detect(formula_ob, "DayNight"), 
         towTime_dtc = str_detect(formula_ob, "towTime")) %>%
  filter(!(mgmt_area_n == 1 & mgmt_area_dtc == TRUE), 
         !(season_n == 1 & season_dtc == TRUE), 
         !(dayNight_n == 1 & dayNight_dtc == TRUE), 
         !(towTime_n == 1 & towTime_dtc == TRUE)) %>%
  mutate(formula = ifelse(trawl_n == 1, (str_replace(formula_ob, "trawl_type +", "")), formula_ob)) %>%
  mutate(formula_clean = str_replace(formula, "~  \\+", " ~ ")) %>%
  select(dataset, data, formula_clean, n) %>%
  group_by(dataset) %>%
  nest(list_of_models = formula_clean) %>%
  ungroup()

clean_list_of_models_monkfish_ob <- datasets_tibble_monkfish_ob$list_of_models


#fitting all the models to each dataset 
models_all_monkfish_ob <- mapply(fit.models_ob, datasets_tibble_monkfish_ob$data, clean_list_of_models_monkfish_ob)


#comparing all the models for all the datasets 
for (i in 1:40) {
comparison_tables_monkfish_ob <- clean_list_of_models_monkfish_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_monkfish_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_monkfish_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_monkfish_ob[[i]])]) %>%
  relocate(rsq, .after = deltaAIC) %>%
  mutate(rsq = sprintf("%0.2f", rsq)) %>%
  mutate(aic = sprintf("%1.0f", aic)) %>%
  mutate(deltaAIC = sprintf("%1.0f", deltaAIC)) %>%
  kbl(col.names = (c("Model", "AIC", "deltaAIC","Deviance Explained"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

print(comparison_tables_monkfish_ob)

}


#extract the optimal model from each table 
for (i in 1:40) {
optimal_models_monkfish_ob <- clean_list_of_models_monkfish_ob[[i]] %>%
  mutate(aic =  purrr::map_dbl(models_all_monkfish_ob[[i]], AIC)) %>%
  mutate(rsq =  purrr::map_dbl(models_all_monkfish_ob[[i]], Dsquared)) %>% 
  arrange(desc(aic)) %>%
  mutate(deltaAIC = aic - aic[length(models_all_monkfish_ob[[i]])]) %>%
  filter(deltaAIC <= 2) %>%
  arrange(desc(rsq))

print(optimal_models_monkfish_ob)

}


#adding a column to the dataframe of the optimal model formula for each dataset
#doing this by hand because I wanted to inspect the optimal model(selection criteria: parsimony, deltaAIC < 2, highest r2)
datasets_tibble_monkfish_ob <- datasets_tibble_monkfish_ob %>%
  mutate(optimal_model = c("", 
                           "", 
                           "", 
                           "",
                           "", #5
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #10
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #15
                           "", 
                           "", 
                           "",
                           "", 
                           "", #20
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #25
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #30
                           "", 
                           "", 
                           "", 
                           "", 
                           "", #35
                           "", 
                           "", 
                           "", 
                           "", 
                           ""  #40
                           ))


#run the optimal model for each dataset from the data_tibble 
dataset_final_monkfish_ob <- datasets_tibble_monkfish_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted = purrr::map(model, fitted)) %>%
  unnest(fitted) %>%
  group_by(dataset) %>%
  mutate(mean_re = mean(fitted), 
         cv = (sd(fitted)/mean(fitted)), 
         se = sd(fitted)/(sqrt(length(fitted)))) %>%
  ungroup() %>%
  nest(fitted = fitted) %>%
  relocate(fitted, .after = results)


#reordering the dataset for plots and to better reflect the purpose 
dataset_final_monkfish_ob <- dataset_final_monkfish_ob[match(paired_tow_levels_ob, dataset_final_monkfish$dataset), ]


dataset_final_monkfish_ob

#plotting the RE estimate and SE and sample size 
dataset_final_monkfish_ob %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", n, ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re)) + 
  geom_errorbar(aes(x = label, ymin = mean_re - se, ymax = mean_re + se)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  coord_flip() 


#plotting the RE estimate and SE and sample size by trawl type
datasets_tibble_monkfish_ob %>%
  mutate(model = purrr::map2(optimal_model, data, ~glm(.x, family = binomial, data = .y))) %>%
  mutate(results = purrr::map(model, broom::tidy)) %>%
  mutate(fitted_vals = purrr::map(model, fitted)) %>% 
  mutate(data = map2(data, fitted_vals, ~mutate(.x, fitted = .y))) %>%
  unnest(data) %>%
  group_by(dataset, trawl_type) %>%
  summarise(mean_re_bytrawl = mean(fitted), 
         cv_bytrawl = (sd(fitted)/mean(fitted)), 
         se_bytrawl = sd(fitted)/(sqrt(length(fitted))), 
         n_bytrawl = n_distinct(trip_haul_ID)) %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  mutate(label = paste0(match_crit, " (n = ", sum(n_bytrawl), ")")) %>%
  ggplot() + 
  geom_point(aes(x = fct_inorder(label), y = mean_re_bytrawl, color = trawl_type)) + 
  geom_errorbar(aes(x = label, ymin = mean_re_bytrawl - se_bytrawl, ymax = mean_re_bytrawl + se_bytrawl, color = trawl_type)) + 
  labs(x = "Matching Criteria", y = "Estimated Relative Efficiency ") + 
  scale_color_discrete(labels=c("1" = "Groundfish Trawls", "2" = "Flatfish Trawls",
                              "3" = "Separator Trawls", "4" = "Eliminator Trawls")) + 
  coord_flip() 


  

#table for the important information 
dataset_final_monkfish_ob %>%
  ungroup() %>%
  mutate(match_crit = str_sub(dataset, 13)) %>%
  mutate(match_crit = str_replace(match_crit, "_", " & ")) %>%
  select(match_crit, n, optimal_model, mean_re, cv, se) %>%
  mutate(mean_re = sprintf("%0.2f", mean_re)) %>%
  mutate(cv = sprintf("%0.2f", cv)) %>%
  mutate(se = sprintf("%0.2f", se)) %>%
  kbl(col.names = (c("Matching Criteria", "Sample Size", "Optimal Model","Relative Efficiency Estimate", "CV", "Standard Error"))) %>%
  kable_classic("striped", full_width = FALSE) %>%
  kable_styling()

```



